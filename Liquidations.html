<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Liquidation Tracker Pro</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<style>
:root {
  /* Цветовая схема - Темная тема */
  --bg-primary: #0f172a;
  --bg-secondary: #1e293b;
  --bg-card: #1e293b;
  --bg-input: #334155;
  --text-primary: #f1f5f9;
  --text-secondary: #cbd5e1;
  --text-muted: #94a3b8;
  --primary: #4361ee;
  --primary-hover: #3a56d4;
  --secondary: #6c757d;
  --success: #10b981;
  --danger: #ef4444;
  --warning: #f59e0b;
  --info: #0ea5e9;
  --border: #334155;
  --shadow: rgba(0, 0, 0, 0.25);
  
  /* Градиенты */
  --gradient-primary: linear-gradient(135deg, #4361ee, #3a0ca3);
  
  /* Цвета для ликвидаций */
  --long-color: #10b981;
  --short-color: #ef4444;
  
  /* Тепловая карта */
  --heatmap-low: rgba(16, 185, 129, 0.3);
  --heatmap-medium: rgba(245, 158, 11, 0.5);
  --heatmap-high: rgba(239, 68, 68, 0.7);
  
  /* Анимации */
  --transition: all 0.3s ease;
}

.light {
  /* Цветовая схема - Светлая тема */
  --bg-primary: #f1f5f9;
  --bg-secondary: #ffffff;
  --bg-card: #ffffff;
  --bg-input: #e2e8f0;
  --text-primary: #1e293b;
  --text-secondary: #334155;
  --text-muted: #64748b;
  --border: #cbd5e1;
  --shadow: rgba(0, 0, 0, 0.05);
  
  /* Цвета для ликвидаций */
  --long-color: #047857;
  --short-color: #dc2626;
  
  /* Тепловая карта */
  --heatmap-low: rgba(16, 185, 129, 0.2);
  --heatmap-medium: rgba(245, 158, 11, 0.3);
  --heatmap-high: rgba(239, 68, 68, 0.4);
}

/* Базовые стили */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 16px;
  scroll-behavior: smooth;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.6;
  min-height: 100vh;
  transition: var(--transition);
}

.container {
  max-width: 1920px;
  margin: 0 auto;
  padding: 1rem;
  display: grid;
  grid-template-columns: 1fr;
  gap: 1.5rem;
}

/* Шапка */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 1rem;
  padding: 1rem;
  background: var(--bg-secondary);
  border-radius: 12px;
  box-shadow: 0 4px 6px var(--shadow);
}

.logo {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.logo-icon {
  width: 42px;
  height: 42px;
  border-radius: 50%;
  background: var(--gradient-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 1.5rem;
}

.logo-text {
  font-size: 1.5rem;
  font-weight: 700;
  background: var(--gradient-primary);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header-controls {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  align-items: center;
}

.symbol-navigation {
  display: flex;
  align-items: center;
  background: var(--bg-input);
  border-radius: 8px;
  padding: 0.25rem;
}

.symbol-nav-btn {
  background: none;
  border: none;
  width: 36px;
  height: 36px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  cursor: pointer;
  transition: var(--transition);
}

.symbol-nav-btn:hover {
  background: rgba(255, 255, 255, 0.05);
  color: var(--text-primary);
}

.current-symbol {
  min-width: 100px;
  text-align: center;
  font-weight: 600;
  padding: 0 0.75rem;
  font-size: 1.1rem;
}

.language-selector {
  position: relative;
}

.language-btn {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: var(--bg-input);
  border: none;
  border-radius: 8px;
  padding: 0.5rem 1rem;
  color: var(--text-primary);
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
}

.language-btn:hover {
  background: rgba(255, 255, 255, 0.05);
}

.language-dropdown {
  position: absolute;
  top: 100%;
  right: 0;
  width: 180px;
  background: var(--bg-secondary);
  border-radius: 8px;
  padding: 0.5rem;
  margin-top: 0.5rem;
  box-shadow: 0 4px 12px var(--shadow);
  z-index: 100;
  display: none;
  flex-direction: column;
  gap: 0.25rem;
}

.language-dropdown.show {
  display: flex;
}

.language-option {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem;
  border-radius: 6px;
  cursor: pointer;
  transition: var(--transition);
}

.language-option:hover {
  background: var(--bg-input);
}

#themeBtn {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: var(--bg-input);
  border: none;
  border-radius: 8px;
  padding: 0.5rem 1rem;
  color: var(--text-primary);
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
}

#themeBtn:hover {
  background: rgba(255, 255, 255, 0.05);
}

/* Статус и подсказки */
.status {
  padding: 1rem;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-weight: 500;
}

.status.connecting {
  background: rgba(245, 158, 11, 0.15);
  color: #f59e0b;
}

.status.connected {
  background: rgba(16, 185, 129, 0.15);
  color: #10b981;
}

.status.error {
  background: rgba(239, 68, 68, 0.15);
  color: #ef4444;
}

.hint {
  padding: 1rem;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  background: rgba(14, 165, 233, 0.15);
  color: #0ea5e9;
  font-weight: 500;
}

/* Панель управления */
.control-panel {
  background: var(--bg-secondary);
  border-radius: 12px;
  box-shadow: 0 4px 6px var(--shadow);
  overflow: hidden;
}

.panel-header {
  padding: 1.25rem 1.5rem;
  background: var(--bg-input);
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.panel-title {
  font-size: 1.25rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.controls-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1.5rem;
  padding: 1.5rem;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.control-label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 500;
  color: var(--text-primary);
}

.control-label i {
  color: var(--primary);
}

input, select {
  width: 100%;
  padding: 0.75rem 1rem;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text-primary);
  font-family: inherit;
  font-size: 1rem;
  transition: var(--transition);
}

input:focus, select:focus {
  outline: none;
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
}

select {
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2394a3b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 1rem center;
  background-size: 1rem;
  cursor: pointer;
}

button {
  padding: 0.75rem 1.25rem;
  background: var(--primary);
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  font-family: inherit;
  font-size: 1rem;
  cursor: pointer;
  transition: var(--transition);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

button:hover {
  background: var(--primary-hover);
  transform: translateY(-2px);
}

button.secondary {
  background: var(--bg-input);
  color: var(--text-primary);
}

button.secondary:hover {
  background: rgba(255, 255, 255, 0.1);
}

.alert-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 1.5rem;
  border-top: 1px solid var(--border);
}

.alert-toggle {
  position: relative;
  display: inline-block;
  width: 50px;
  height: 26px;
}

.alert-toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}

.alert-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--bg-input);
  transition: var(--transition);
  border-radius: 34px;
}

.alert-slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 4px;
  bottom: 4px;
  background-color: var(--text-secondary);
  transition: var(--transition);
  border-radius: 50%;
}

input:checked + .alert-slider {
  background-color: var(--primary);
}

input:checked + .alert-slider:before {
  transform: translateX(24px);
  background-color: white;
}

.filter-controls {
  display: flex;
  gap: 1.5rem;
  padding: 0 1.5rem 1.5rem;
}

.filter-group {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* Статистика */
.stats-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
  gap: 1.5rem;
}

.stat-card {
  background: var(--bg-secondary);
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 4px 6px var(--shadow);
  display: flex;
  flex-direction: column;
  gap: 1rem;
  transition: var(--transition);
  position: relative;
  overflow: hidden;
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: var(--primary);
}

.stat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.stat-title {
  font-weight: 600;
  color: var(--text-secondary);
  font-size: 0.95rem;
}

.stat-icon {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  background: rgba(67, 97, 238, 0.15);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--primary);
  font-size: 1.25rem;
}

.stat-value {
  font-size: 1.75rem;
  font-weight: 700;
}

.trend-indicator {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.9rem;
  font-weight: 500;
}

.trend-up {
  color: var(--success);
}

.trend-down {
  color: var(--danger);
}

.ratio-display {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.ratio-text {
  font-size: 0.85rem;
  color: var(--text-muted);
}

.ratio-bar {
  width: 100%;
  height: 8px;
  background: var(--bg-input);
  border-radius: 4px;
  overflow: hidden;
}

.long-ratio {
  height: 100%;
  background: var(--long-color);
  border-radius: 4px;
  transition: width 0.5s ease;
}

/* Графики и таблицы */
.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.section-title {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-size: 1.25rem;
  font-weight: 600;
}

.chart-container, .table-container {
  background: var(--bg-secondary);
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 4px 6px var(--shadow);
}

.chart-container {
  grid-column: 1 / -1;
}

.data-container {
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 1.5rem;
}

@media (max-width: 1200px) {
  .data-container {
    grid-template-columns: 1fr;
  }
}

canvas {
  width: 100% !important;
  height: 300px !important;
}

.heatmap-container {
  margin-top: 2rem;
}

.heatmap-title {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 500;
  margin-bottom: 0.75rem;
  color: var(--text-primary);
}

.heatmap {
  display: flex;
  height: 20px;
  gap: 2px;
  border-radius: 4px;
  overflow: hidden;
}

.heatmap-bar {
  transition: all 0.5s ease;
}

table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.95rem;
}

th {
  text-align: left;
  padding: 0.75rem 1rem;
  background: var(--bg-input);
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  position: relative;
  user-select: none;
}

th:hover {
  background: rgba(255, 255, 255, 0.05);
}

th.sort-asc::after, th.sort-desc::after {
  content: '';
  position: absolute;
  right: 1rem;
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
}

th.sort-asc::after {
  border-bottom: 5px solid var(--text-muted);
  top: 50%;
  transform: translateY(-50%);
}

th.sort-desc::after {
  border-top: 5px solid var(--text-muted);
  top: 50%;
  transform: translateY(-50%);
}

td {
  padding: 0.75rem 1rem;
  border-bottom: 1px solid var(--border);
}

tr:last-child td {
  border-bottom: none;
}

tr.long-liquidation {
  background: rgba(16, 185, 129, 0.05);
}

tr.short-liquidation {
  background: rgba(239, 68, 68, 0.05);
}

tr.large-volume {
  position: relative;
  overflow: hidden;
}

tr.large-liquidation::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  animation: highlight 1.5s ease;
}

tr.long-liquidation.large-liquidation::before {
  background: var(--long-color);
}

tr.short-liquidation.large-liquidation::before {
  background: var(--short-color);
}

.price-cell {
  font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
  font-weight: 500;
}

/* Карта ликвидности */
.liquidity-map-container {
  grid-column: 1 / -1;
}

.liquidity-map {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  max-height: 400px;
  overflow-y: auto;
  padding-right: 0.5rem;
}

.liquidity-map::-webkit-scrollbar {
  width: 6px;
}

.liquidity-map::-webkit-scrollbar-track {
  background: var(--bg-input);
  border-radius: 4px;
}

.liquidity-map::-webkit-scrollbar-thumb {
  background: var(--primary);
  border-radius: 4px;
}

.liquidity-level {
  display: grid;
  grid-template-columns: 120px 1fr 120px;
  align-items: center;
  gap: 1rem;
  padding: 0.75rem;
  background: var(--bg-input);
  border-radius: 8px;
}

.level-bar {
  height: 20px;
  background: var(--bg-card);
  border-radius: 4px;
  overflow: hidden;
}

.level-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.5s ease;
}

.level-price, .level-volume {
  font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
  font-weight: 500;
}

/* Подвал */
.footer {
  grid-column: 1 / -1;
  text-align: center;
  padding: 1.5rem;
  color: var(--text-muted);
  font-size: 0.9rem;
}

/* Анимации */
@keyframes highlight {
  0% { width: 100%; opacity: 0.3; }
  100% { width: 4px; opacity: 1; }
}

.large-liquidation {
  animation: pulse 1s;
}

@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(67, 97, 238, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(67, 97, 238, 0); }
  100% { box-shadow: 0 0 0 0 rgba(67, 97, 238, 0); }
}

/* Адаптивность */
@media (max-width: 1024px) {
  .controls-grid {
    grid-template-columns: 1fr;
  }
  
  .stats-cards {
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  }
}

@media (max-width: 768px) {
  .header {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .header-controls {
    width: 100%;
    flex-wrap: wrap;
  }
  
  .symbol-navigation {
    order: 1;
    width: 100%;
  }
  
  .filter-controls {
    flex-direction: column;
    gap: 0.75rem;
  }
  
  .data-container {
    grid-template-columns: 1fr;
  }
  
  .liquidity-level {
    grid-template-columns: 1fr;
    gap: 0.5rem;
  }
  
  .level-price, .level-volume {
    font-size: 0.9rem;
  }
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="logo">
      <div class="logo-icon">
        <i class="fas fa-bolt"></i>
      </div>
      <div class="logo-text" id="appTitle">Liquidation Tracker Pro</div>
    </div>
    
    <div class="header-controls">
      <div class="symbol-navigation">
        <button class="symbol-nav-btn" id="prevSymbol">
          <i class="fas fa-chevron-left"></i>
        </button>
        <div class="current-symbol" id="currentSymbol">-</div>
        <button class="symbol-nav-btn" id="nextSymbol">
          <i class="fas fa-chevron-right"></i>
        </button>
      </div>
      
      <div class="language-selector">
        <button class="language-btn" id="languageBtn">
          <span class="flag" id="currentFlag">🇺🇸</span>
          <span id="currentLanguage">English</span>
          <i class="fas fa-chevron-down"></i>
        </button>
        <div class="language-dropdown" id="languageDropdown">
          <div class="language-option" data-lang="en">
            <span class="flag">🇺🇸</span>
            <span>English</span>
          </div>
          <div class="language-option" data-lang="ru">
            <span class="flag">🇷🇺</span>
            <span>Русский</span>
          </div>
          <div class="language-option" data-lang="uk">
            <span class="flag">🇺🇦</span>
            <span>Українська</span>
          </div>
        </div>
      </div>
      
      <button id="themeBtn">
        <i class="fas fa-moon"></i>
        <span id="themeText">Light Theme</span>
      </button>
    </div>
  </div>

  <div class="status" id="status">
    <i class="fas fa-spinner fa-spin"></i>
    <span id="statusText">Loading symbols...</span>
  </div>

  <div class="hint" id="hint" style="display: none;">
    <i class="fas fa-info-circle"></i>
    <span id="hintText"></span>
  </div>

  <div class="control-panel">
    <div class="panel-header">
      <div class="panel-title">
        <i class="fas fa-tachometer-alt"></i>
        <span id="controlsTitle">Controls Dashboard</span>
      </div>
    </div>
    
    <div class="controls-grid">
      <div class="control-group">
        <label class="control-label">
          <i class="fas fa-search"></i>
          <span id="searchLabel">Search symbol</span>
        </label>
        <input type="text" id="symbolSearch" placeholder="BTC, ETH, SOL..." />
      </div>
      
      <div class="control-group">
        <label class="control-label">
          <i class="fas fa-coins"></i>
          <span id="selectLabel">Select symbol</span>
        </label>
        <select id="symbolSelect" size="5"></select>
      </div>
      
      <div class="control-group">
        <label class="control-label">
          <i class="fas fa-filter"></i>
          <span id="volumeLabel">Minimum volume (USD)</span>
        </label>
        <input type="number" id="minVolume" value="1000" min="0" step="100" />
      </div>
      
      <div class="control-group">
        <label class="control-label">
          <i class="fas fa-clock"></i>
          <span id="timeframeLabel">Timeframe</span>
        </label>
        <select id="timeframeSelect">
          <option value="1" id="time1">1 minute</option>
          <option value="5" selected id="time5">5 minutes</option>
          <option value="15" id="time15">15 minutes</option>
          <option value="60" id="time60">1 hour</option>
        </select>
      </div>
      
      <div class="control-group">
        <label class="control-label">
          <i class="fas fa-cog"></i>
          <span id="actionsLabel">Actions</span>
        </label>
        <div style="display: flex; gap: 10px;">
          <button id="pauseBtn">
            <i class="fas fa-pause"></i>
            <span id="pauseText">Pause</span>
          </button>
          <button class="secondary" id="clearBtn">
            <i class="fas fa-trash"></i>
            <span id="clearText">Clear</span>
          </button>
        </div>
      </div>
      
      <div class="control-group">
        <label class="control-label">
          <i class="fas fa-exclamation-triangle"></i>
          <span id="thresholdLabel">Large Liquidation Threshold ($)</span>
        </label>
        <input type="number" id="largeThreshold" value="10000" min="0" step="1000" />
      </div>

      <div class="control-group">
        <label class="control-label">
          <i class="fas fa-calculator"></i>
          <span id="calcLabel">Liquidation Calculator</span>
        </label>
        <div style="display: grid; gap: 10px; grid-template-columns: 1fr 1fr;">
          <input type="number" id="entryPrice" placeholder="Entry price">
          <input type="number" id="leverage" placeholder="Leverage (1-100)" min="1" max="100" value="10">
          <select id="positionType">
            <option value="long">Long</option>
            <option value="short">Short</option>
          </select>
          <button id="calculateBtn">
            <i class="fas fa-calculator"></i>
            <span id="calcText">Calculate</span>
          </button>
        </div>
        <div id="calcResult" style="margin-top: 10px; font-weight: 600;"></div>
      </div>
    </div>
    
    <div class="alert-controls">
      <label class="control-label">
        <i class="fas fa-bell"></i>
        <span id="alertLabel">Alerts for large liquidations</span>
      </label>
      <label class="alert-toggle">
        <input type="checkbox" id="alertToggle">
        <span class="alert-slider"></span>
      </label>
    </div>
    
    <div class="filter-controls">
      <div class="filter-group">
        <input type="checkbox" id="showLongs" checked>
        <label for="showLongs" id="showLongsLabel">Show Long Liquidations</label>
      </div>
      <div class="filter-group">
        <input type="checkbox" id="showShorts" checked>
        <label for="showShorts" id="showShortsLabel">Show Short Liquidations</label>
      </div>
    </div>
  </div>

  <div class="stats-cards">
    <div class="stat-card">
      <div class="stat-header">
        <div class="stat-title" id="totalVolumeTitle">Total Volume</div>
        <div class="stat-icon">
          <i class="fas fa-chart-pie"></i>
        </div>
      </div>
      <div class="stat-value" id="totalVolume">$0</div>
      <div class="trend-indicator" id="totalVolumeTrend">
        <i class="fas fa-arrow-up trend-up"></i>
        <span class="trend-value">0%</span>
      </div>
    </div>
    
    <div class="stat-card">
      <div class="stat-header">
        <div class="stat-title" id="buyVolumeTitle">Buy Volume</div>
        <div class="stat-icon">
          <i class="fas fa-arrow-trend-up"></i>
        </div>
      </div>
      <div class="stat-value" id="buyVolume">$0</div>
      <div class="trend-indicator" id="buyVolumeTrend">
        <i class="fas fa-arrow-up trend-up"></i>
        <span class="trend-value">0%</span>
      </div>
    </div>
    
    <div class="stat-card">
      <div class="stat-header">
        <div class="stat-title" id="sellVolumeTitle">Sell Volume</div>
        <div class="stat-icon">
          <i class="fas fa-arrow-trend-down"></i>
        </div>
      </div>
      <div class="stat-value" id="sellVolume">$0</div>
      <div class="trend-indicator" id="sellVolumeTrend">
        <i class="fas fa-arrow-up trend-up"></i>
        <span class="trend-value">0%</span>
      </div>
    </div>
    
    <div class="stat-card">
      <div class="stat-header">
        <div class="stat-title" id="largeLiquidationsTitle">Large Liquidations</div>
        <div class="stat-icon">
          <i class="fas fa-fire"></i>
        </div>
      </div>
      <div class="stat-value" id="largeLiquidations">0</div>
      <div class="ratio-display">
        <div class="ratio-text" id="ratioLabel">Long/Short Ratio</div>
        <div class="ratio-bar">
          <div class="long-ratio" id="longRatioBar" style="width: 50%"></div>
        </div>
        <div class="ratio-text" id="longRatioText">50%</div>
      </div>
    </div>
  </div>

  <!-- Карта ликвидности перенесена сюда (выше графика и таблицы) -->
  <div class="chart-container liquidity-map-container">
    <div class="section-header">
      <div class="section-title">
        <i class="fas fa-map"></i>
        <span id="liquidityTitle">Liquidity Heatmap</span>
      </div>
    </div>
    <div class="liquidity-map" id="liquidityMap"></div>
  </div>

  <div class="data-container">
    <div class="chart-container">
      <div class="section-header">
        <div class="section-title">
          <i class="fas fa-chart-line"></i>
          <span id="chartTitle">Volume Chart</span>
        </div>
      </div>
      <canvas id="chart"></canvas>
      
      <div class="heatmap-container">
        <div class="heatmap-title">
          <i class="fas fa-fire"></i>
          <span id="heatmapTitle">Liquidation Heatmap (Last 15 intervals)</span>
        </div>
        <div class="heatmap" id="heatmap"></div>
      </div>
    </div>
    
    <div class="table-container">
      <div class="section-header">
        <div class="section-title">
          <i class="fas fa-table-list"></i>
          <span id="tableTitle">Liquidation Events</span>
        </div>
        <button class="secondary" id="exportBtn">
          <i class="fas fa-file-export"></i>
          <span id="exportText">Export CSV</span>
        </button>
      </div>
      <table>
        <thead>
          <tr>
            <th data-sort="time" id="timeHeader">Time</th>
            <th data-sort="type" id="typeHeader">Type</th>
            <th data-sort="price" id="priceHeader">Price</th>
            <th data-sort="volume" id="volumeHeader">Volume</th>
          </tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>

  <div class="footer">
    <p id="footerText">Liquidation Tracker Pro v3.0 &copy; 2025 | Data provided by Binance WebSocket</p>
  </div>
</div>

<audio id="alertSound">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3" type="audio/mpeg">
</audio>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  // Current language
  const translations = {
    en: {
      appTitle: "Liquidation Tracker Pro",
      themeText: "Light Theme",
      controlsTitle: "Controls Dashboard",
      searchLabel: "Search symbol",
      selectLabel: "Select symbol",
      volumeLabel: "Minimum volume (USD)",
      timeframeLabel: "Timeframe",
      time1: "1 minute",
      time5: "5 minutes",
      time15: "15 minutes",
      time60: "1 hour",
      actionsLabel: "Actions",
      resumeText: "Resume",
      pauseText: "Pause",
      clearText: "Clear",
      thresholdLabel: "Large Liquidation Threshold ($)",
      alertLabel: "Alerts for large liquidations",
      showLongsLabel: "Show Long Liquidations",
      showShortsLabel: "Show Short Liquidations",
      totalVolumeTitle: "Total Volume",
      buyVolumeTitle: "Buy Volume",
      sellVolumeTitle: "Sell Volume",
      largeLiquidationsTitle: "Large Liquidations",
      ratioLabel: "Long/Short Ratio",
      chartTitle: "Volume Chart",
      heatmapTitle: "Liquidation Heatmap (Last 15 intervals)",
      tableTitle: "Liquidation Events",
      exportText: "Export CSV",
      timeHeader: "Time",
      typeHeader: "Type",
      priceHeader: "Price",
      volumeHeader: "Volume",
      footerText: "Liquidation Tracker Pro v3.0 &copy; 2025 | Data provided by Binance WebSocket",
      loadingSymbols: "Loading symbols...",
      connecting: "Connecting to Binance",
      connected: "Connected to Binance",
      reconnecting: "Reconnecting in 3 seconds...",
      connectionError: "Connection error:",
      noSymbols: "No symbols found",
      exportError: "No data to export",
      longLiq: "Long Liq",
      shortLiq: "Short Liq",
      alertTitle: "Large Liquidation Alert",
      hintText: "After selecting token, reload the page",
      calcLabel: "Liquidation Calculator",
      calcText: "Calculate",
      liquidityTitle: "Liquidity Heatmap",
      liquidationPrice: "Liquidation Price:",
      invalidInput: "Please enter valid numbers",
      calcInstructions: "Enter entry price and leverage to calculate liquidation price"
    },
    ru: {
      appTitle: "Трекер Ликвидаций Про",
      themeText: "Светлая тема",
      controlsTitle: "Панель управления",
      searchLabel: "Поиск символа",
      selectLabel: "Выбор символа",
      volumeLabel: "Минимальный объем (USD)",
      timeframeLabel: "Временной интервал",
      time1: "1 минута",
      time5: "5 минут",
      time15: "15 минут",
      time60: "1 час",
      actionsLabel: "Действия",
      resumeText: "Продолжить",
      pauseText: "Пауза",
      clearText: "Очистить",
      thresholdLabel: "Порог крупной ликвидации ($)",
      alertLabel: "Оповещения для крупных ликвидаций",
      showLongsLabel: "Показывать длинные ликвидации",
      showShortsLabel: "Показывать короткие ликвидации",
      totalVolumeTitle: "Общий объем",
      buyVolumeTitle: "Объем покупок",
      sellVolumeTitle: "Объем продаж",
      largeLiquidationsTitle: "Крупные ликвидации",
      ratioLabel: "Соотношение Long/Short",
      chartTitle: "График объема",
      heatmapTitle: "Карта ликвидаций (последние 15 интервалов)",
      tableTitle: "События ликвидаций",
      exportText: "Экспорт CSV",
      timeHeader: "Время",
      typeHeader: "Тип",
      priceHeader: "Цена",
      volumeHeader: "Объем",
      footerText: "Трекер Ликвидаций Про v3.0 &copy; 2025 | Данные предоставлены Binance WebSocket",
      loadingSymbols: "Загрузка символов...",
      connecting: "Подключение к Binance",
      connected: "Подключено к Binance",
      reconnecting: "Переподключение через 3 секунды...",
      connectionError: "Ошибка подключения:",
      noSymbols: "Символы не найдены",
      exportError: "Нет данных для экспорта",
      longLiq: "Лонг Ликв",
      shortLiq: "Шорт Ликв",
      alertTitle: "Оповещение о крупной ликвидации",
      hintText: "После выбора токена перезагрузи страницу",
      calcLabel: "Калькулятор ликвидаций",
      calcText: "Рассчитать",
      liquidityTitle: "Карта ликвидности",
      liquidationPrice: "Цена ликвидации:",
      invalidInput: "Пожалуйста, введите корректные числа",
      calcInstructions: "Введите цену входа и кредитное плечо для расчета цены ликвидации"
    },
    uk: {
      appTitle: "Трекер Ліквідацій Про",
      themeText: "Світла тема",
      controlsTitle: "Панель управління",
      searchLabel: "Пошук символу",
      selectLabel: "Вибір символу",
      volumeLabel: "Мінімальний об'єм (USD)",
      timeframeLabel: "Часовий інтервал",
      time1: "1 хвилина",
      time5: "5 хвилин",
      time15: "15 хвилин",
      time60: "1 година",
      actionsLabel: "Дії",
      resumeText: "Продовжити",
      pauseText: "Пауза",
      clearText: "Очистити",
      thresholdLabel: "Поріг великої ліквідації ($)",
      alertLabel: "Оповіщення для великих ліквідацій",
      showLongsLabel: "Показувати довгі ліквідації",
      showShortsLabel: "Показувати короткі ліквідації",
      totalVolumeTitle: "Загальний об'єм",
      buyVolumeTitle: "Об'єм покупок",
      sellVolumeTitle: "Об'єм продажів",
      largeLiquidationsTitle: "Великі ліквідації",
      ratioLabel: "Співвідношення Long/Short",
      chartTitle: "Графік об'єму",
      heatmapTitle: "Карта ліквідацій (останні 15 інтервалів)",
      tableTitle: "Події ліквідацій",
      exportText: "Експорт CSV",
      timeHeader: "Час",
      typeHeader: "Тип",
      priceHeader: "Ціна",
      volumeHeader: "Об'єм",
      footerText: "Трекер Ліквідацій Про v3.0 &copy; 2025 | Дані надані Binance WebSocket",
      loadingSymbols: "Завантаження символів...",
      connecting: "Підключення до Binance",
      connected: "Підключено до Binance",
      reconnecting: "Перепідключення через 3 секунди...",
      connectionError: "Помилка підключення:",
      noSymbols: "Символи не знайдені",
      exportError: "Немає даних для експорту",
      longLiq: "Лонг Лікв",
      shortLiq: "Шорт Лікв",
      alertTitle: "Оповіщення про велику ліквідацію",
      hintText: "Після вибору токена перезавантаж сторінку",
      calcLabel: "Калькулятор ліквідацій",
      calcText: "Розрахувати",
      liquidityTitle: "Карта ліквідності",
      liquidationPrice: "Ціна ліквідації:",
      invalidInput: "Будь ласка, введіть коректні числа",
      calcInstructions: "Введіть ціну входу та кредитне плече для розрахунку ціни ліквідації"
    }
  };

  // Конфигурация
  const MAX_EVENTS = 500;
  const HEATMAP_SIZE = 15;
  const MAX_EVENTS_PER_SECOND = 50;
  let currentLanguage = 'en';
  let allSymbols = [];
  let totalVolume = 0;
  let buyVolume = 0;
  let sellVolume = 0;
  let largeLiquidations = 0;
  let longLiquidations = 0;
  let shortLiquidations = 0;
  let events = [];
  let prevTotalVolume = 0;
  let prevBuyVolume = 0;
  let prevSellVolume = 0;
  let eventCounter = 0;
  let lastReset = Date.now();
  let currentSymbolIndex = 0;

  // DOM elements
  const statusElement = document.getElementById('status');
  const statusTextElement = document.getElementById('statusText');
  const symbolSelect = document.getElementById("symbolSelect");
  const minVolumeInput = document.getElementById("minVolume");
  const timeframeSelect = document.getElementById("timeframeSelect");
  const tableBody = document.getElementById("tableBody");
  const chartCtx = document.getElementById("chart").getContext("2d");
  const symbolSearch = document.getElementById("symbolSearch");
  const pauseBtn = document.getElementById("pauseBtn");
  const themeBtn = document.getElementById("themeBtn");
  const clearBtn = document.getElementById("clearBtn");
  const largeThresholdInput = document.getElementById("largeThreshold");
  const showLongsCheckbox = document.getElementById("showLongs");
  const showShortsCheckbox = document.getElementById("showShorts");
  const alertToggle = document.getElementById("alertToggle");
  const alertSound = document.getElementById("alertSound");
  const exportBtn = document.getElementById("exportBtn");
  const longRatioBar = document.getElementById("longRatioBar");
  const longRatioText = document.getElementById("longRatioText");
  const heatmap = document.getElementById("heatmap");
  const languageBtn = document.getElementById("languageBtn");
  const languageDropdown = document.getElementById("languageDropdown");
  const currentFlag = document.getElementById("currentFlag");
  const currentLanguageText = document.getElementById("currentLanguage");
  const hintElement = document.getElementById("hint");
  const hintTextElement = document.getElementById("hintText");
  const prevSymbolBtn = document.getElementById("prevSymbol");
  const nextSymbolBtn = document.getElementById("nextSymbol");
  const currentSymbolElement = document.getElementById("currentSymbol");
  const entryPriceInput = document.getElementById("entryPrice");
  const leverageInput = document.getElementById("leverage");
  const positionTypeSelect = document.getElementById("positionType");
  const calculateBtn = document.getElementById("calculateBtn");
  const calcResultElement = document.getElementById("calcResult");
  const liquidityMapElement = document.getElementById("liquidityMap");
  const totalVolumeTrendElement = document.getElementById("totalVolumeTrend");
  const buyVolumeTrendElement = document.getElementById("buyVolumeTrend");
  const sellVolumeTrendElement = document.getElementById("sellVolumeTrend");
  
  // Stats elements
  const totalVolumeElement = document.getElementById("totalVolume");
  const buyVolumeElement = document.getElementById("buyVolume");
  const sellVolumeElement = document.getElementById("sellVolume");
  const largeLiquidationsElement = document.getElementById("largeLiquidations");

  // App state
  let socket;
  let buffer = [];
  let paused = false;
  let chart;
  let currentTimeframe = 5;
  let intervalTimer = null;
  let currentIntervalStart = null;
  let sortField = "time";
  let sortDirection = "desc";
  let heatmapData = [];

  // Apply language to UI
  function applyLanguage(lang) {
    currentLanguage = lang;
    const t = translations[lang];

    // Update UI elements
    document.getElementById('appTitle').textContent = t.appTitle;
    document.getElementById('themeText').textContent = t.themeText;
    document.getElementById('controlsTitle').textContent = t.controlsTitle;
    document.getElementById('searchLabel').textContent = t.searchLabel;
    document.getElementById('selectLabel').textContent = t.selectLabel;
    document.getElementById('volumeLabel').textContent = t.volumeLabel;
    document.getElementById('timeframeLabel').textContent = t.timeframeLabel;
    document.getElementById('time1').textContent = t.time1;
    document.getElementById('time5').textContent = t.time5;
    document.getElementById('time15').textContent = t.time15;
    document.getElementById('time60').textContent = t.time60;
    document.getElementById('actionsLabel').textContent = t.actionsLabel;
    document.getElementById('pauseText').textContent = paused ? t.resumeText : t.pauseText;
    document.getElementById('clearText').textContent = t.clearText;
    document.getElementById('thresholdLabel').textContent = t.thresholdLabel;
    document.getElementById('alertLabel').textContent = t.alertLabel;
    document.getElementById('showLongsLabel').textContent = t.showLongsLabel;
    document.getElementById('showShortsLabel').textContent = t.showShortsLabel;
    document.getElementById('totalVolumeTitle').textContent = t.totalVolumeTitle;
    document.getElementById('buyVolumeTitle').textContent = t.buyVolumeTitle;
    document.getElementById('sellVolumeTitle').textContent = t.sellVolumeTitle;
    document.getElementById('largeLiquidationsTitle').textContent = t.largeLiquidationsTitle;
    document.getElementById('ratioLabel').textContent = t.ratioLabel;
    document.getElementById('chartTitle').textContent = t.chartTitle;
    document.getElementById('heatmapTitle').textContent = t.heatmapTitle;
    document.getElementById('tableTitle').textContent = t.tableTitle;
    document.getElementById('exportText').textContent = t.exportText;
    document.getElementById('timeHeader').textContent = t.timeHeader;
    document.getElementById('typeHeader').textContent = t.typeHeader;
    document.getElementById('priceHeader').textContent = t.priceHeader;
    document.getElementById('volumeHeader').textContent = t.volumeHeader;
    document.getElementById('footerText').textContent = t.footerText;
    hintTextElement.textContent = t.hintText;
    document.getElementById('calcLabel').textContent = t.calcLabel;
    document.getElementById('calcText').textContent = t.calcText;
    document.getElementById('liquidityTitle').textContent = t.liquidityTitle;
    calcResultElement.textContent = t.calcInstructions;

    // Update current language display
    if (lang === 'en') {
      currentFlag.textContent = '🇺🇸';
      currentLanguageText.textContent = 'English';
    } else if (lang === 'ru') {
      currentFlag.textContent = '🇷🇺';
      currentLanguageText.textContent = 'Русский';
    } else if (lang === 'uk') {
      currentFlag.textContent = '🇺🇦';
      currentLanguageText.textContent = 'Українська';
    }
    
    // Re-render table to update text
    renderTable();

    // Save language preference
    localStorage.setItem("language", lang);
  }

  // Update status display
  function updateStatus(text, isError = false) {
    statusTextElement.textContent = text;
    statusElement.className = 'status';
    
    if (isError) {
      statusElement.classList.add('error');
    } else if (text.includes('Connecting') || text.includes('Loading') || text.includes('Reconnecting')) {
      statusElement.classList.add('connecting');
    } else {
      statusElement.classList.add('connected');
    }
  }

  // Initialize chart
  function initializeChart() {
    if(chart) chart.destroy();
    
    // Определяем цвета в зависимости от темы
    const isLight = document.body.classList.contains('light');
    const longColor = isLight ? '#047857' : '#10b981';
    const shortColor = isLight ? '#dc2626' : '#ef4444';
    const priceLineColor = isLight ? '#3a56d4' : '#4361ee';

    return new Chart(chartCtx, {
      type: "bar",
      data: {
        labels: [],
        datasets: [
          {
            label: translations[currentLanguage].longLiq,
            backgroundColor: longColor,
            data: [],
            borderRadius: 6,
            borderSkipped: false,
          },
          {
            label: translations[currentLanguage].shortLiq,
            backgroundColor: shortColor,
            data: [],
            borderRadius: 6,
            borderSkipped: false,
          },
          {
            label: "Price",
            type: "line",
            data: [],
            borderColor: priceLineColor,
            backgroundColor: "rgba(67, 97, 238, 0.1)",
            yAxisID: "y1",
            fill: true,
            pointRadius: 0,
            tension: 0.4
          }
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 500 },
        scales: {
          x: {
            stacked: true,
            grid: {
              color: 'rgba(255,255,255,0.1)'
            },
            ticks: {
              color: 'rgba(255,255,255,0.7)'
            }
          },
          y: {
            stacked: true,
            beginAtZero: true,
            grid: {
              color: 'rgba(255,255,255,0.1)'
            },
            ticks: {
              color: 'rgba(255,255,255,0.7)',
              callback: function(value) {
                return '$' + value;
              }
            }
          },
          y1: {
            position: 'right',
            grid: { drawOnChartArea: false },
            ticks: { color: 'rgba(67, 97, 238, 0.8)' }
          }
        },
        plugins: {
          legend: {
            labels: {
              color: '#e0e0e0',
              font: {
                weight: 'bold'
              }
            }
          },
          tooltip: {
            backgroundColor: 'rgba(30, 41, 59, 0.9)',
            titleColor: '#f8fafc',
            bodyColor: '#e2e8f0',
            borderColor: 'rgba(67, 97, 238, 0.5)',
            borderWidth: 1,
            padding: 12,
            callbacks: {
              label: function(context) {
                return context.dataset.label + ': $' + context.parsed.y.toFixed(0);
              }
            }
          }
        }
      },
    });
  }

  // Update stats cards
  function updateStats() {
    totalVolumeElement.textContent = '$' + formatNumber(Math.round(totalVolume));
    buyVolumeElement.textContent = '$' + formatNumber(Math.round(buyVolume));
    sellVolumeElement.textContent = '$' + formatNumber(Math.round(sellVolume));
    largeLiquidationsElement.textContent = largeLiquidations;

    // Update long/short ratio
    const total = longLiquidations + shortLiquidations;
    const longRatio = total > 0 ? Math.round((longLiquidations / total) * 100) : 50;
    longRatioBar.style.width = longRatio + '%';
    longRatioText.textContent = longRatio + '%';

    // Update trends
    updateTrends();
  }
  
  // Format large numbers
  function formatNumber(num) {
    if (num >= 1000000) {
      return (num / 1000000).toFixed(2) + 'M';
    } else if (num >= 1000) {
      return (num / 1000).toFixed(1) + 'K';
    }
    return num.toLocaleString();
  }

  // Update trends
  function updateTrends() {
    updateTrend(totalVolume, prevTotalVolume, totalVolumeTrendElement);
    updateTrend(buyVolume, prevBuyVolume, buyVolumeTrendElement);
    updateTrend(sellVolume, prevSellVolume, sellVolumeTrendElement);
    
    // Save current values for next comparison
    prevTotalVolume = totalVolume;
    prevBuyVolume = buyVolume;
    prevSellVolume = sellVolume;
  }

  function updateTrend(currentValue, previousValue, element) {
    if (previousValue === 0 || currentValue === previousValue) {
      element.innerHTML = '<i class="fas fa-minus"></i> <span class="trend-value">0%</span>';
      return;
    }
    
    const change = ((currentValue - previousValue) / previousValue * 100).toFixed(2);
    const isPositive = change >= 0;
    
    element.innerHTML = `
      <i class="fas fa-arrow-${isPositive ? 'up' : 'down'} trend-${isPositive ? 'up' : 'down'}"></i>
      <span class="trend-value">${Math.abs(change)}%</span>
    `;
  }

  // Update chart with new data
  function updateChart(longs, shorts, price) {
    const now = new Date();
    const label = now.toLocaleTimeString();
    chart.data.labels.push(label);
    chart.data.datasets[0].data.push(longs);
    chart.data.datasets[1].data.push(shorts);
    
    if (price) {
      chart.data.datasets[2].data.push(price);
    }
    
    if (chart.data.labels.length > HEATMAP_SIZE) {
      chart.data.labels.shift();
      chart.data.datasets[0].data.shift();
      chart.data.datasets[1].data.shift();
      chart.data.datasets[2].data.shift();
    }
    
    chart.update();
    
    // Update heatmap
    heatmapData.push(longs + shorts);
    if (heatmapData.length > HEATMAP_SIZE) heatmapData.shift();
    updateHeatmap();
  }

  // Update heatmap visualization
  function updateHeatmap() {
    heatmap.innerHTML = '';
    if (heatmapData.length === 0) return;
    
    const maxValue = Math.max(...heatmapData);
    const minValue = Math.min(...heatmapData);
    const range = maxValue - minValue || 1; // Avoid division by zero
    
    heatmapData.forEach(value => {
      const normalized = (value - minValue) / range;
      let color;
      let intensity;
      
      if (normalized < 0.3) {
        color = 'var(--heatmap-low)';
        intensity = 'Low';
      } else if (normalized < 0.7) {
        color = 'var(--heatmap-medium)';
        intensity = 'Medium';
      } else {
        color = 'var(--heatmap-high)';
        intensity = 'High';
      }
      
      const bar = document.createElement('div');
      bar.className = 'heatmap-bar';
      bar.style.background = color;
      bar.style.flex = '1';
      bar.title = `$${Math.round(value).toLocaleString()} - ${intensity} Intensity`;
      heatmap.appendChild(bar);
    });
  }

  // Start aggregation interval
  function startAggregationInterval(timeframe) {
    clearTimeout(intervalTimer);
    currentTimeframe = timeframe;
    currentIntervalStart = Date.now();
    intervalTimer = setTimeout(() => aggregateBuffer(), currentTimeframe * 60000);
  }

  // Aggregate buffer data based on timeframe
  function aggregateBuffer() {
    if (paused) {
      buffer = [];
      return;
    }
    
    const endInterval = currentIntervalStart + currentTimeframe * 60000;
    const eventsInInterval = buffer.filter(event => 
      event.timestamp >= currentIntervalStart && event.timestamp < endInterval
    );
    buffer = buffer.filter(event => 
      !(event.timestamp >= currentIntervalStart && event.timestamp < endInterval)
    );

    let longs = 0;
    let shorts = 0;
    let lastPrice = 0;

    eventsInInterval.forEach((event) => {
      if (event.type === translations[currentLanguage].longLiq) {
        longs += event.volume;
        sellVolume += event.volume;  // лонг ликв = продажи
      } else {
        shorts += event.volume;
        buyVolume += event.volume;   // шорт ликв = покупки
      }
      lastPrice = event.price;
    });
    
    totalVolume += longs + shorts;

    if (longs + shorts > 0) {
      updateChart(longs, shorts, lastPrice);
      updateStats();
    }
    
    currentIntervalStart = endInterval;
    intervalTimer = setTimeout(() => aggregateBuffer(), currentTimeframe * 60000);
  }

  // Add event to table
  function addEventToTable(event) {
    const largeThreshold = parseFloat(largeThresholdInput.value) || 10000;
    const isLarge = event.volume > largeThreshold;
    
    if (isLarge) {
      largeLiquidations++;
      if (event.type === translations[currentLanguage].longLiq) {
        longLiquidations++;
      } else {
        shortLiquidations++;
      }
      
      // Trigger alert if enabled
      if (alertToggle.checked) {
        triggerAlert(event);
      }
    }
    
    // Ограничение размера массива событий
    if (events.length >= MAX_EVENTS) {
      events.shift();
    }
    
    events.push(event);
    
    // Частичная перерисовка таблицы
    renderTable();
  }

  // Trigger alert for large liquidation
  function triggerAlert(event) {
    try {
      // Play sound
      alertSound.currentTime = 0;
      alertSound.play().catch(e => console.log("Audio play failed:", e));
      
      // Show browser notification if supported
      if (Notification.permission === "granted") {
        new Notification(`${translations[currentLanguage].alertTitle} - ${event.symbol}`, {
          body: `${event.type} at $${event.price.toFixed(2)}\nVolume: $${event.volume.toFixed(0)}`,
          icon: "https://cdn-icons-png.flaticon.com/512/607/607870.png"
        });
      }
    } catch (e) {
      console.log("Alert failed:", e);
    }
  }

  // Функция форматирования цены с большим количеством знаков
  function formatPrice(price) {
    // Для цен > 1000 показываем 2 знака после запятой
    if (price > 1000) {
      return price.toFixed(2);
    }
    // Для цен > 1 показываем 4 знака
    if (price > 1) {
      return price.toFixed(4);
    }
    // Для мелких цен показываем до 8 знаков
    return price.toFixed(8).replace(/\.?0+$/, '');
  }

  // Render table with events
  function renderTable() {
    const showLongs = showLongsCheckbox.checked;
    const showShorts = showShortsCheckbox.checked;
    const minVolume = parseFloat(minVolumeInput.value) || 0;

    // Filter events based on checkboxes and min volume
    const filteredEvents = events.filter(event => {
      if (event.volume < minVolume) return false;
      if (event.type === translations[currentLanguage].longLiq && !showLongs) return false;
      if (event.type === translations[currentLanguage].shortLiq && !showShorts) return false;
      return true;
    });

    // Sort events
    filteredEvents.sort((a, b) => {
      if (sortField === "time") {
        return sortDirection === "asc" ? a.timestamp - b.timestamp : b.timestamp - a.timestamp;
      } else if (sortField === "price") {
        return sortDirection === "asc" ? a.price - b.price : b.price - a.price;
      } else if (sortField === "volume") {
        return sortDirection === "asc" ? a.volume - b.volume : b.volume - a.volume;
      } else if (sortField === "type") {
        return sortDirection === "asc" ? 
          a.type.localeCompare(b.type) : b.type.localeCompare(a.type);
      }
      return 0;
    });

    // Render table
    tableBody.innerHTML = '';
    filteredEvents.slice(0, MAX_EVENTS).forEach(event => {
      const largeThreshold = parseFloat(largeThresholdInput.value) || 10000;
      const isLarge = event.volume > largeThreshold;
      const isLong = event.type === translations[currentLanguage].longLiq;
      
      const row = document.createElement("tr");
      
      // Добавляем класс в зависимости от типа ликвидации
      if (isLong) {
        row.classList.add("long-liquidation");
      } else {
        row.classList.add("short-liquidation");
      }
      
      if (isLarge) {
        row.classList.add("large-volume", "large-liquidation");
        // Remove animation class after animation completes
        setTimeout(() => {
          row.classList.remove("large-liquidation");
        }, 2000);
      }
      
      row.innerHTML = `
        <td>${event.time}</td>
        <td>${event.type}</td>
        <td class="price-cell">${formatPrice(event.price)}</td>
        <td>$${formatNumber(event.volume)}</td>
      `;
      tableBody.appendChild(row);
    });
  }

  // Calculate liquidation price
  function calculateLiquidation() {
    const t = translations[currentLanguage];
    const entryPrice = parseFloat(entryPriceInput.value);
    const leverage = parseFloat(leverageInput.value);
    const positionType = positionTypeSelect.value;

    if (isNaN(entryPrice) || isNaN(leverage) || leverage < 1 || leverage > 100) {
      calcResultElement.textContent = t.invalidInput;
      calcResultElement.style.color = 'var(--danger)';
      return;
    }
    
    // Simplified liquidation price calculation
    const maintenanceMargin = 0.005; // 0.5%
    let liquidationPrice;
    
    if (positionType === 'long') {
      liquidationPrice = entryPrice * (1 - (1 / leverage) + maintenanceMargin);
    } else {
      liquidationPrice = entryPrice * (1 + (1 / leverage) - maintenanceMargin);
    }
    
    calcResultElement.innerHTML = `${t.liquidationPrice} <strong>${liquidationPrice.toFixed(4)}</strong>`;
    calcResultElement.style.color = 'var(--text-dark)';
  }

  // Update liquidity heatmap with REAL data
  async function updateLiquidityMap() {
    const symbol = symbolSelect.value.toUpperCase();
    const limit = 100; // Limit the number of levels for better visualization

    try {
        const response = await fetch(`https://fapi.binance.com/fapi/v1/depth?symbol=${symbol}&limit=${limit}`);
        if (!response.ok) {
            liquidityMapElement.innerHTML = 'Could not fetch liquidity data.';
            return;
        }
        const data = await response.json();

        // Asks are resistance levels (red), Bids are support levels (green)
        const asks = data.asks.map(level => ({ 
            price: parseFloat(level[0]), 
            volume: parseFloat(level[1]) * parseFloat(level[0]),
            type: 'ask'
        }));
        const bids = data.bids.map(level => ({ 
            price: parseFloat(level[0]), 
            volume: parseFloat(level[1]) * parseFloat(level[0]),
            type: 'bid'
        }));
        
        // Combine and sort by price descending
        const allLevels = [...asks, ...bids].sort((a, b) => b.price - a.price);
        if (allLevels.length === 0) return;

        const maxVolume = Math.max(...allLevels.map(level => level.volume));
        
        liquidityMapElement.innerHTML = ''; // Clear old map

        allLevels.forEach(level => {
            const levelElement = document.createElement('div');
            levelElement.className = 'liquidity-level';
            
            const widthPercentage = (level.volume / maxVolume * 100).toFixed(0);
            
            // Исправленные цвета: ask (красный), bid (зеленый)
            const color = level.type === 'ask' ? 'var(--short-color)' : 'var(--long-color)';
            
            levelElement.innerHTML = `
                <div class="level-price">${formatPrice(level.price)}</div>
                <div class="level-bar">
                    <div class="level-fill" style="width: ${widthPercentage}%; background: ${color};"></div>
                </div>
                <div class="level-volume">$${formatNumber(Math.round(level.volume))}</div>
            `;
            
            liquidityMapElement.appendChild(levelElement);
        });

    } catch (error) {
        console.error("Error fetching liquidity map data:", error);
        liquidityMapElement.innerHTML = 'Error loading data.';
    }
  }

  // Connect to WebSocket
  function connect(symbol) {
    updateStatus(`${translations[currentLanguage].connecting} ${symbol}...`);
    // Закрытие предыдущего соединения
    if (socket) {
      socket.close();
    }
    
    const formattedSymbol = symbol.toLowerCase();
    try {
      socket = new WebSocket(`wss://fstream.binance.com/ws/${formattedSymbol}@aggTrade`);
    } catch (error) {
      updateStatus(`${translations[currentLanguage].connectionError} ${error}`, true);
      setTimeout(() => connect(symbol), 3000);
      return;
    }

    socket.onopen = () => {
      updateStatus(`${translations[currentLanguage].connected} ${symbol}`);
      startAggregationInterval(currentTimeframe);
      currentSymbolElement.textContent = symbol;
      updateLiquidityMap(); 
    };

    socket.onmessage = (event) => {
      if (paused) return;
      
      // Защита от перегрузки
      const now = Date.now();
      if (now - lastReset > 1000) {
        eventCounter = 0;
        lastReset = now;
      }
      
      if (eventCounter > MAX_EVENTS_PER_SECOND) {
        console.warn("Event rate limit exceeded");
        return;
      }
      
      eventCounter++;

      try {
        const data = JSON.parse(event.data);
        // Process Binance data
        const price = parseFloat(data.p);
        const qty = parseFloat(data.q);
        const volume = price * qty;
        
        // Исправлено определение типа ликвидации:
        // data.m === true - шорт ликвидация (вынужденная покупка)
        // data.m === false - лонг ликвидация (вынужденная продажа)
        const type = data.m ? translations[currentLanguage].shortLiq : translations[currentLanguage].longLiq;
        
        const time = new Date(data.T).toLocaleTimeString();
        const minVolume = parseFloat(minVolumeInput.value) || 0;

        const eventObj = {
          symbol,
          time,
          type,
          price,
          volume,
          timestamp: data.T
        };

        // Add to table if volume passes filter
        if (eventObj.volume >= minVolume) {
          addEventToTable(eventObj);
        }

        // Update buffer for aggregation
        buffer.push({ 
          type,
          qty, 
          price,
          volume,
          timestamp: data.T
        });

        // Update stats
        if (type === translations[currentLanguage].longLiq) {
          sellVolume += volume;  // лонг ликв = продажи
        } else {
          buyVolume += volume;   // шорт ликв = покупки
        }
        totalVolume += volume;
        
        updateStats();
      } catch (error) {
        console.error('Error processing message:', error);
      }
    };

    socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      updateStatus(`${translations[currentLanguage].connectionError} ${error.message || 'Unknown'}`, true);
    };

    socket.onclose = (event) => {
      if (!paused && event.code !== 1000) {
        updateStatus(`${translations[currentLanguage].reconnecting} (${event.reason || 'Unknown'})`, true);
        setTimeout(() => connect(symbol), 3000);
      }
    };
  }

  // Initialize app
  async function init() {
    chart = initializeChart();
    // Request notification permission
    if (Notification.permission !== "granted") {
      try {
        await Notification.requestPermission();
      } catch (e) {
        console.log("Notification permission error:", e);
      }
    }
    
    try {
      updateStatus(translations[currentLanguage].loadingSymbols);
      const res = await fetch("https://api.binance.com/api/v3/exchangeInfo");
      if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
      
      const data = await res.json();
      allSymbols = data.symbols
        .filter((s) => s.status === 'TRADING' && s.symbol.endsWith("USDT"))
        .map((s) => s.symbol);

      if (allSymbols.length === 0) throw new Error(translations[currentLanguage].noSymbols);

      renderSymbolOptions(allSymbols);

      const savedSymbol = localStorage.getItem("selectedSymbol");
      const initialSymbol = savedSymbol && allSymbols.includes(savedSymbol) 
        ? savedSymbol 
        : allSymbols[0];

      symbolSelect.value = initialSymbol.toLowerCase();
      currentSymbolIndex = allSymbols.indexOf(initialSymbol);
      connect(initialSymbol);
      updateStatus('');
    } catch (error) {
      updateStatus(`Error: ${error.message}`, true);
    }
  }

  // Render symbol options
  function renderSymbolOptions(symbols) {
    symbolSelect.innerHTML = symbols
      .map((sym) => `<option value="${sym.toLowerCase()}">${sym}</option>`)
      .join("");
  }

  // Sort table
  function sortTable(field) {
    if (sortField === field) {
      sortDirection = sortDirection === "asc" ? "desc" : "asc";
    } else {
      sortField = field;
      sortDirection = "desc";
    }
    
    // Update UI
    document.querySelectorAll('th').forEach(th => {
      th.classList.remove('sort-asc', 'sort-desc');
    });
    const header = document.querySelector(`th[data-sort="${field}"]`);
    if (header) {
      header.classList.add(`sort-${sortDirection}`);
    }
    
    renderTable();
  }

  // Export to CSV
  function exportToCSV() {
    if (events.length === 0) {
      alert(translations[currentLanguage].exportError);
      return;
    }
    
    const headers = ['Time', 'Type', 'Price', 'Volume (USD)'];
    const rows = events.map(event => [
      event.time,
      event.type,
      event.price,
      Math.round(event.volume)
    ]);
    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `liquidation_events_${new Date().toISOString().slice(0, 10)}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  
symbolSelect.addEventListener("change", () => {
  const selected = symbolSelect.value.toUpperCase();

  // Save symbol
  localStorage.setItem("selectedSymbol", selected);

  // Reset all data
  buffer = [];
  events = [];
  totalVolume = 0;
  buyVolume = 0;
  sellVolume = 0;
  largeLiquidations = 0;
  longLiquidations = 0;
  shortLiquidations = 0;
  prevTotalVolume = 0;
  prevBuyVolume = 0;
  prevSellVolume = 0;
  heatmapData = [];
  renderTable();
  updateStats();

  // Hide hint (if shown)
  hintElement.style.display = 'none';

  // Reconnect WebSocket and update liquidity
  connect(selected);
});


// Navigate symbols
  function navigateSymbols(direction) {
    currentSymbolIndex += direction;
    if (currentSymbolIndex < 0) {
      currentSymbolIndex = allSymbols.length - 1;
    } else if (currentSymbolIndex >= allSymbols.length) {
      currentSymbolIndex = 0;
    }
    
    const symbol = allSymbols[currentSymbolIndex];
    symbolSelect.value = symbol.toLowerCase();
    // Trigger symbol change
    symbolSelect.dispatchEvent(new Event('change'));
  }

  // Save all settings
  function saveAllSettings() {
    const settings = {
      theme: document.body.classList.contains("light") ? "light" : "dark",
      language: currentLanguage,
      timeframe: currentTimeframe,
      minVolume: minVolumeInput.value,
      largeThreshold: largeThresholdInput.value,
      showLongs: showLongsCheckbox.checked,
      showShorts: showShortsCheckbox.checked,
      alertToggle: alertToggle.checked,
      symbol: symbolSelect.value.toUpperCase()
    };
    localStorage.setItem("appSettings", JSON.stringify(settings));
  }

  // Load all settings
  function loadAllSettings() {
    const savedSettings = localStorage.getItem("appSettings");
    if (savedSettings) {
      const settings = JSON.parse(savedSettings);

      // Apply settings
      if (settings.theme === "light") {
        document.body.classList.add("light");
        themeBtn.querySelector('i').className = 'fas fa-sun';
      }
      
      applyLanguage(settings.language || 'en');

      if (settings.timeframe) {
        timeframeSelect.value = settings.timeframe;
        currentTimeframe = parseInt(settings.timeframe);
      }
      
      minVolumeInput.value = settings.minVolume || 1000;
      largeThresholdInput.value = settings.largeThreshold || 10000;
      showLongsCheckbox.checked = settings.showLongs !== false;
      showShortsCheckbox.checked = settings.showShorts !== false;
      alertToggle.checked = settings.alertToggle || false;

      return settings.symbol;
    }
    return null;
  }

  // Event listeners
  symbolSearch.addEventListener("input", () => {
    const query = symbolSearch.value.toUpperCase();
    const filtered = allSymbols.filter((sym) => sym.includes(query));
    renderSymbolOptions(filtered);
  });

  symbolSelect.addEventListener("change", () => {
    const symbol = symbolSelect.value.toUpperCase();
    localStorage.setItem("selectedSymbol", symbol);
    currentSymbolIndex = allSymbols.indexOf(symbol);
    
    // Полный сброс данных
    tableBody.innerHTML = "";
    events = [];
    buffer = [];
    totalVolume = 0;
    buyVolume = 0;
    sellVolume = 0;
    largeLiquidations = 0;
    longLiquidations = 0;
    shortLiquidations = 0;
    heatmapData = [];
    
    clearTimeout(intervalTimer);
    intervalTimer = null;
    
    updateStats();
    initializeChart();
    updateHeatmap();
    updateLiquidityMap();
    
    // Переподключение
    connect(symbol);
    
    // Показать подсказку
    hintElement.style.display = 'flex';
    hintTextElement.textContent = translations[currentLanguage].hintText;
    
    // Save settings
    saveAllSettings();
  });

  minVolumeInput.addEventListener("change", () => {
    renderTable();
    saveAllSettings();
  });

  largeThresholdInput.addEventListener("change", () => {
    renderTable();
    saveAllSettings();
  });

  pauseBtn.addEventListener("click", () => {
    paused = !paused;
    
    if (paused) {
      pauseBtn.querySelector('span').textContent = translations[currentLanguage].resumeText;
      pauseBtn.querySelector('i').className = 'fas fa-play';
      
      // Закрытие сокета при паузе
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.close();
      }
      clearTimeout(intervalTimer);
    } else {
      pauseBtn.querySelector('span').textContent = translations[currentLanguage].pauseText;
      pauseBtn.querySelector('i').className = 'fas fa-pause';
      connect(symbolSelect.value.toUpperCase());
    }
  });

  themeBtn.addEventListener("click", () => {
    document.body.classList.toggle("light");
    const isLight = document.body.classList.contains("light");
    themeBtn.querySelector('span').textContent = isLight ? translations[currentLanguage].themeText : translations[currentLanguage].themeText;
    themeBtn.querySelector('i').className = isLight ? 'fas fa-sun' : 'fas fa-moon';
    saveAllSettings();
    initializeChart();
  });

  clearBtn.addEventListener("click", () => {
    tableBody.innerHTML = "";
    events = [];
    buffer = [];
    totalVolume = 0;
    buyVolume = 0;
    sellVolume = 0;
    largeLiquidations = 0;
    longLiquidations = 0;
    shortLiquidations = 0;
    heatmapData = [];
    updateStats();
    initializeChart();
    updateHeatmap();
    updateLiquidityMap();
  });

  timeframeSelect.addEventListener("change", () => {
    const newTimeframe = parseInt(timeframeSelect.value);
    localStorage.setItem("timeframe", newTimeframe);
    
    // Сброс текущего интервала
    clearTimeout(intervalTimer);
    
    // Агрегация оставшихся данных
    aggregateBuffer();
    
    // Запуск нового интервала
    startAggregationInterval(newTimeframe);
    
    saveAllSettings();
  });

  showLongsCheckbox.addEventListener("change", () => {
    renderTable();
    saveAllSettings();
  });

  showShortsCheckbox.addEventListener("change", () => {
    renderTable();
    saveAllSettings();
  });
  
  alertToggle.addEventListener("change", saveAllSettings);
  
  exportBtn.addEventListener("click", exportToCSV);

  // Add sort handlers to table headers
  document.querySelectorAll('th[data-sort]').forEach(th => {
    th.addEventListener('click', () => {
      sortTable(th.getAttribute('data-sort'));
    });
  });

  // Language selector
  languageBtn.addEventListener('click', () => {
    languageDropdown.classList.toggle('show');
  });

  document.querySelectorAll('.language-option').forEach(option => {
    option.addEventListener('click', () => {
      const lang = option.getAttribute('data-lang');
      applyLanguage(lang);
      languageDropdown.classList.remove('show');
      // Reinitialize chart to update labels
      initializeChart();
      saveAllSettings();
    });
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!languageBtn.contains(e.target) && !languageDropdown.contains(e.target)) {
      languageDropdown.classList.remove('show');
    }
  });

  // Symbol navigation
  prevSymbolBtn.addEventListener('click', () => navigateSymbols(-1));
  nextSymbolBtn.addEventListener('click', () => navigateSymbols(1));
  
  // Liquidation calculator
  calculateBtn.addEventListener('click', calculateLiquidation);

  // Initialize settings
  const savedSymbol = loadAllSettings();
  
  // Initialize language from localStorage if not set by settings
  if (!currentLanguage) {
    const savedLanguage = localStorage.getItem("language") || 'en';
    applyLanguage(savedLanguage);
  }
  
  // Initialize the app
  init();
  
  // Periodically update liquidity map
  setInterval(updateLiquidityMap, 10000);
</script>
</body>
</html>
